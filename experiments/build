#!/bin/bash

SCRIPT=$(readlink -f $0)
SCRIPT_PATH=$(dirname "${SCRIPT}")
PARENT_PATH=$(dirname "${SCRIPT_PATH}")

source "${SCRIPT_PATH}/common.sh"

CONFIG_FILES=("${SCRIPT_PATH}/experiment.cfg")

log_file="${SCRIPT_PATH}/log/build.log"

mkdir -p "${SCRIPT_PATH}/log"
chmod -f g=u "${SCRIPT_PATH}/log"
rm -f ${log_file}
touch ${log_file}
chmod -f g=u ${log_file}

# flags for command options
opt_all=0
opt_data_tools=0
opt_prepare_system=''
opt_system=''
opt_experiment=''
opt_no_func=1

function usage {
    echo "Usage: build [Options]
	  
Options:
  -h, --help				print this message.
  -a, --all				build all dependencies for experiments. (DEFAULT OPTION)
  -t, --data-tools			build data-tools.
  -p, --prepare-system <sys1,sys2,...>	prepare systems. 
  -s, --system <sys1,sys2,...>		build excutable for systems.
  -e, --experiment <exp1,exp2,...> 	produce data and compile queries for experimeents.

Examples:
  (1) build
	Equals to 'build -a' or 'build -t -p all -s all -e all'. Build all dependencies for experiments.

  (2) build -t -p dbtoaster
	Build data-tools, then compile and assembly dbtoaster. 

  (3) build -s dbtoaster,flink 
	Build exectuables for system dbtoaster and flink.

  (4) build -s flink -e length3 
	Prepare data and compile query of experiment 'length3', then build executable for system flink.
"
    exit 1
}

if [[ $# -eq 0 ]]; then
    # 'build' is equals to 'build -a' or 'build --all'
    opt_all=1
else
    opt_args=$(getopt -a -n build -o hatp:s:e:n --long help,all,data-tools,prepare-system:,system:,experiment:,no-func -- "$@")
    if [[ $? -ne 0 ]]; then
        usage
    fi

    eval set -- "${opt_args}"
    while :; do
        case $1 in
            -h | --help) usage ;;
            -a | --all) opt_all=1; shift ;;
            -t | --data-tools) opt_data_tools=1; shift ;;
            -p | --prepare-system) opt_prepare_system=$2; shift 2 ;;
            -s | --system) opt_system=$2; shift 2 ;;
            -e | --experiment) opt_experiment=$2; shift 2 ;;
            --) shift; break ;;
            *) echo "Unexpected option: $1."; usage ;;
        esac
    done
fi

if [[ ${opt_all} -eq 1 ]]; then
    if [[ ${opt_data_tools} -eq 1 ]]; then
        echo "Warning: option -a already implies option -t."
    fi

    if [[ -n ${opt_prepare_system} ]]; then
        echo "Warning: option -a already implies option -p all."
    fi

    if [[ -n ${opt_system} ]]; then
        echo "Warning: option -a already implies option -s all."
    fi

    if [[ -n ${opt_experiment} ]]; then
        echo "Warning: option -a already implies option -e all."
    fi

    # option -a equals to -t -p all -s all -e all
    opt_data_tools=1
    opt_prepare_system='all'
    opt_system='all'
    opt_experiment='all'
fi

# flags for handling cases that dbtoaster_cpp is set in -p option
contains_dbtoaster=0
contains_dbtoaster_cpp=0

# check if system names in option -p is valid
if [[ -n ${opt_prepare_system} ]]; then
    if [[ ${opt_prepare_system} == 'all' ]]; then
        opt_prepare_system_names=${valid_system_names[@]}
        contains_dbtoaster=1
        contains_dbtoaster_cpp=1
    else
        opt_prepare_system_names=$(echo ${opt_prepare_system} | awk -F, '{for(i=1;i<=NF;i++) printf "%s%s",$i,ORS}')
        for system_name in ${opt_prepare_system_names[@]}; do
            is_valid=0
            for name in ${valid_system_names[@]}; do
                if [[ ${system_name} == ${name} ]]; then
                    is_valid=1
                fi
            done

            if [[ "${system_name}" = "dbtoaster" ]]; then
                contains_dbtoaster=1
            fi

            if [[ "${system_name}" = "dbtoaster_cpp" ]]; then
                contains_dbtoaster_cpp=1
            fi

            if [[ ${is_valid} -eq 0 ]]; then
                echo "Unexpected system name ${system_name} in option -p"
                usage
            fi
        done
    fi
fi

# TBD: how to understand
# if dbtoaster_cpp is set in -p but dbtoaster is not set, prepare dbtoaster instead
if [[ ${contains_dbtoaster_cpp} -eq 1 && ${contains_dbtoaster} -eq 0 ]]; then
    opt_prepare_system_names+=('dbtoaster')
    opt_prepare_system_names=( ${opt_prepare_system_names[@]/dbtoaster_cpp} )
# if dbtoaster_cpp and dbtoaster are both set, drop dbtoaster_cpp because dbtoaster will do the job
elif [[ ${contains_dbtoaster_cpp} -eq 1 && ${contains_dbtoaster} -eq 1 ]]; then
    opt_prepare_system_names=( ${opt_prepare_system_names[@]/dbtoaster_cpp} )
fi

# check if system names in option -s is valid
if [[ -n ${opt_system} ]]; then
    if [[ ${opt_system} == 'all' ]]; then
        opt_system_names=${valid_system_names[@]}
    else
        opt_system_names=$(echo ${opt_system} | awk -F, '{for(i=1;i<=NF;i++) printf "%s%s",$i,ORS}')
        for system_name in ${opt_system_names[@]}; do
            is_valid=0
            for name in ${valid_system_names[@]}; do
                if [[ ${system_name} == ${name} ]]; then
                    is_valid=1
                fi
            done

            if [[ ${is_valid} -eq 0 ]]; then
                echo "Unexpected system name ${system_name} in option -s"
                usage
            fi
        done
    fi
fi

# check if experiment names in option -e is valid
if [[ -n ${opt_experiment} ]]; then
    if [[ ${opt_experiment} == 'all' ]]; then
        opt_experiment_names=${valid_experiment_names[@]}
    else
        opt_experiment_names=$(echo ${opt_experiment} | awk -F, '{for(i=1;i<=NF;i++) printf "%s%s",$i,ORS}')
        for experiment_name in ${opt_experiment_names[@]}; do
            is_valid=0
            for name in ${valid_experiment_names[@]}; do
                if [[ ${experiment_name} == ${name} ]]; then
                    is_valid=1
                fi
            done

            if [[ ${is_valid} -eq 0 ]]; then
                echo "Unexpected experiment name ${experiment_name} in option -e"
                usage
            fi
        done
    fi
fi

if [[ ${opt_data_tools} -eq 1 ]]; then
    echo "begin to build data-tools." >> ${log_file}

    # Combine bash ${SCRIPT_PATH}/data/prepare-tools.sh
    CONFIG_FILES=("${SCRIPT_PATH}/data/tools.cfg")
    log_file_temp="${SCRIPT_PATH}/data/log/prepare-tools.log"
    mkdir -p "${SCRIPT_PATH}/data/log"
    chmod -f g=rwx "${SCRIPT_PATH}/data/log"
    rm -f ${log_file_temp}
    touch ${log_file_temp}
    chmod -f g=rw ${log_file_temp}
    producer_home=$(prop 'data.tools.home')
    cd ${producer_home}
    rm -rf "${producer_home}/target/"
    rm -rf "${producer_home}/project/target/"
    rm -rf "${producer_home}/project/project/"
    sbt clean >> ${log_file_temp} 2>&1
    sbt compile >> ${log_file_temp} 2>&1
    assert "data tools compile failed."
    sbt assembly >> ${log_file_temp} 2>&1
    assert "data tools assembly failed."
    chmod -Rf g=u "${producer_home}/target"
    chmod -Rf g=u "${producer_home}/project"
    cd ${SCRIPT_PATH}
    # Combine end

    assert "build data-tools failed."
    echo "finish building data-tools." >> ${log_file}
fi

for system in ${opt_prepare_system_names[@]}; do
    echo "begin to prepare system ${system}" >> ${log_file}

    # Combine bash ${SCRIPT_PATH}/${system}/prepare-system.sh
    if [[ "${system}" == "dbtoaster" ]]; then
        CONFIG_FILES=("${SCRIPT_PATH}/dbtoaster/experiment.cfg")
        log_file_temp="${SCRIPT_PATH}/dbtoaster/log/prepare-system.log"
        mkdir -p "${SCRIPT_PATH}/dbtoaster/log"
        chmod -f g=u "${SCRIPT_PATH}/dbtoaster/log"
        rm -f ${log_file_temp}
        touch ${log_file_temp}
        chmod -f g=u ${log_file_temp}
        dbtoaster_home=$(prop 'dbtoaster.backend.home')
        cd ${dbtoaster_home}
        rm -rf "${dbtoaster_home}/target"
        rm -rf "${dbtoaster_home}/project/target"
        rm -rf "${dbtoaster_home}/project/project"
        sbt clean >> ${log_file_temp}
        sbt compile >> ${log_file_temp}
        assert "dbtoaster compile failed."
        release_path="${dbtoaster_home}/ddbtoaster/release"
        sbt release >> ${log_file_temp}
        assert "dbtoaster release failed."
        rm -rf "${SCRIPT_PATH}/dbtoaster/lib"
        mkdir -p "${SCRIPT_PATH}/dbtoaster/lib"
        cp ${release_path}/lib/dbt_scala/dbtoaster*.jar ${SCRIPT_PATH}/dbtoaster/lib/
        chmod -Rf g=u "${release_path}"
        chmod -Rf g=u "${SCRIPT_PATH}/dbtoaster/lib/"
        chmod -Rf g=u "${dbtoaster_home}/target"
        chmod -Rf g=u "${dbtoaster_home}/project"
        cd ${SCRIPT_PATH}
    fi
    # Combine end

    assert "prepare system ${system} failed."
    echo "finish preparing system ${system}" >> ${log_file}
done

for experiment in ${opt_experiment_names[@]}; do
    if [[ ${experiment} != snb* ]]; then
        # snb experiments don't need to produce data
        echo "begin to produce data for experiment ${experiment}" >> ${log_file}

        # Combine bash ${SCRIPT_PATH}/data/produce-data.sh ${experiment}
        # >> bash "${SCRIPT_PATH}/data/${experiment}/produce-data.sh"
        support_experiment_names=('length3_filter' 'length3_project' 'length4_filter' 'length4_project' 'star_cnt' 'dumbbell')
        if [[ "${support_experiment_names[*]}" =~ "${experiment}" ]]; then
            CONFIG_FILES=("${SCRIPT_PATH}/data/tools.cfg" "${SCRIPT_PATH}/experiment.cfg")
            log_file_temp="${SCRIPT_PATH}/data/log/produce-data-${experiment}.log"
            mkdir -p "${SCRIPT_PATH}/data/log"
            chmod -f g=rwx "${SCRIPT_PATH}/data/log"
            rm -f ${log_file_temp}
            touch ${log_file_temp}
            chmod -f g=rw ${log_file_temp}
            tools_home=$(prop 'data.tools.home')
            window_factor=$(prop 'experiment.window.factor')
            graph_input_path=$(prop 'graph.input.path')
            graph_raw_path="${SCRIPT_PATH}/data/${experiment}/data.raw"
            graph_output_path="${SCRIPT_PATH}/data/${experiment}/data.csv"
            cp -f ${graph_input_path} "${graph_raw_path}"
            java -jar "${tools_home}/target/data-tools.jar" -w "${graph_raw_path}" "${graph_output_path}" "${window_factor}" >> ${log_file_temp} 2>&1
            chmod -Rf g=rw "${SCRIPT_PATH}/data/${experiment}/"
        else
            # TBD: support experiments maybe increase and need to modify.
            echo "Not support for experiment ${experiment}" >> ${log_file}
        fi
        # Combine end

        assert "produce data for experiment ${experiment} failed."
        echo "finish producing data for experiment ${experiment}" >> ${log_file}
    fi

    # use valid_system_names instead of opt_system_names, or the data will not be updated with 'build -e all; build -s all'
    for system in ${valid_system_names[@]}; do
        data_path=''
        if [[ ${experiment} != snb* ]]; then
            data_path=${SCRIPT_PATH}/data/${experiment}
            
        else
            snb_data_path=$(prop 'snb.data.base.path')
            data_path=${snb_data_path}/${system}/${experiment}
        fi

        if [[ "${system}" == "dbtoaster" ]]; then
            # Combine bash ${SCRIPT_PATH}/${system}/prepare-data.sh ${experiment} ${data_path}
            if [[ -f "${SCRIPT_PATH}/dbtoaster/${experiment}/prepare-data.sh" ]]; then 
                # TBD: Combine
                bash "${SCRIPT_PATH}/dbtoaster/${experiment}/prepare-data.sh" ${data_path}
            else
                # TBD: what is and how to access perf.cfg and func.cfg
                CONFIG_FILES=("${SCRIPT_PATH}/dbtoaster/${experiment}/perf.cfg" "${SCRIPT_PATH}/dbtoaster/${experiment}/common.cfg" "${SCRIPT_PATH}/dbtoaster/experiment.cfg")
                log_file_temp="${SCRIPT_PATH}/dbtoaster/log/prepare-data-${experiment}.log"
                mkdir -p "${SCRIPT_PATH}/dbtoaster/log"
                chmod -f g=u "${SCRIPT_PATH}/dbtoaster/log"
                rm -f ${log_file_temp}
                touch ${log_file_temp}
                chmod -f g=u ${log_file_temp}
                root=$(prop 'hdfs.root.path')
                dist=$(prop 'hdfs.dist.dir')
                dataset=$(prop 'dataset.name')
                hdfs_path=$(prop 'hdfs.cmd.path')
                ${hdfs_path} dfs -mkdir -p ${root}/${dist}/${dataset} >> ${log_file_temp} 2>&1
                assert "HDFS create dataset directory failed."
                ${hdfs_path} dfs -rm -r ${root}/${dist}/${dataset}/checkpoint >> ${log_file_temp} 2>&1
                multiplier=$(prop 'line.count.multiplier' '1')
                batch_size=$(prop 'batch.size.num')
                if [[ ${experiment} = snb* ]]; then
                    files=$(find "${data_path}" -maxdepth 1 -type f -name 'dbtoaster.*.csv')
                    for file in ${files[@]}
                    do
                        filename=$(basename ${file})
                        ${hdfs_path} dfs -put -f "${file}" ${root}/${dist}/${dataset}/${filename} >> ${log_file_temp} 2>&1
                        assert "HDFS put file failed."
                    done
                    # TBD: Need to get data enum-points-perf.txt
                    cp "${data_path}/enum-points-perf.txt" "${SCRIPT_PATH}/dbtoaster/${experiment}/enum-points-perf.txt"
                else
                    files=$(find "${data_path}" -maxdepth 1 -type f -name '*.csv')
                    for file in ${files[@]}
                    do
                        filename=$(basename ${file})
                        # TBD: convertdata
                        bash "${SCRIPT_PATH}/data/convert-data.sh" "dbtoaster" "${file}" "/tmp/${filename}.dbtoaster.tmp" "${multiplier}" "${batch_size}" "${SCRIPT_PATH}/dbtoaster/${experiment}/enum-points-perf.txt"
                        ${hdfs_path} dfs -put -f /tmp/${filename}.dbtoaster.tmp ${root}/${dist}/${dataset}/${filename} >> ${log_file_temp} 2>&1
                        assert "HDFS put file failed."
                        rm -f /tmp/${filename}.dbtoaster.tmp
                    done
                fi
            fi
            # Combine end

            # Combine bash ${SCRIPT_PATH}/${system}/prepare-query.sh ${experiment}
            CONFIG_FILES=("${SCRIPT_PATH}/dbtoaster/${experiment}/common.cfg" "${SCRIPT_PATH}/dbtoaster/experiment.cfg")
            log_file_temp="${SCRIPT_PATH}/dbtoaster/log/prepare-query-${experiment}.log"
            mkdir -p "${SCRIPT_PATH}/dbtoaster/log"
            chmod -f g=u "${SCRIPT_PATH}/dbtoaster/log"
            rm -f ${log_file_temp}
            touch ${log_file_temp}
            chmod -f g=u ${log_file_temp}
            dbtoaster_home=$(prop 'dbtoaster.backend.home')
            cd ${dbtoaster_home}
            # TBD: query.sql?
            query_file="${SCRIPT_PATH}/dbtoaster/${experiment}/query.sql"
            query_template_file="${SCRIPT_PATH}/dbtoaster/${experiment}/query.sql.template"
            output_path="${SCRIPT_PATH}/dbtoaster/src/main/scala/experiments/dbtoaster/${experiment}"
            mkdir -p ${output_path}
            chmod -f g=u ${output_path}
            output_file="${output_path}/query.scala"
            input_insert_only=$(prop 'input.insert.only')
            rm -f "${query_file}"
            cp -f "${query_template_file}" "${query_file}"
            # substitute filter condition in sql template
            # TBD: filter
            filter_value=$(prop 'filter.condition.value' '-1')
            sed -i "s/\${filter\.condition\.value}/${filter_value}/g" "${query_file}"

            echo ${input_insert_only} | grep -qi '^true$'
            if [[ $? -ne 0 ]]; then
                sbt "toast -l spark --batch -O3 -d fake_del -o ${output_file} ${query_file}" >> ${log_file_temp}
            else
                sbt "toast -l spark --batch -O3 -o ${output_file} ${query_file}" >> ${log_file_temp}
            fi
            assert "dbtoaster compile query failed."
            chmod -f g=u ${output_file}

            sed -i "1 ipackage experiments.dbtoaster.${experiment}" ${output_file}
            sed -i '2 iimport experiments.dbtoaster.Executable' ${output_file}
            sed -i '0,/object Query/{s/object Query/object Query extends Executable/}' ${output_file}

            mkdir -p "${SCRIPT_PATH}/dbtoaster/src/main/resources"
            chmod -f g=u "${SCRIPT_PATH}/dbtoaster/src/main/resources"
            mkdir -p "${SCRIPT_PATH}/dbtoaster/src/test/resources"
            chmod -f g=u "${SCRIPT_PATH}/dbtoaster/src/test/resources"

            CONFIG_FILES=("${SCRIPT_PATH}/dbtoaster/${experiment}/perf.cfg" "${SCRIPT_PATH}/dbtoaster/${experiment}/common.cfg" "${SCRIPT_PATH}/dbtoaster/experiment.cfg")
            config="${SCRIPT_PATH}/dbtoaster/src/main/resources/spark.config.${experiment}.perf"
            rm -f ${config}
            echo "spark.master.url=$(prop 'spark.master.url')" >> $config
            echo "spark.partitions.num=$(prop 'spark.partitions.num')" >> $config
            echo "spark.driver.memory=$(prop 'spark.driver.memory')" >> $config
            echo "spark.executor.memory=$(prop 'spark.executor.memory')" >> $config
            echo "spark.executor.cores=$(prop 'spark.executor.cores')" >> $config
            echo "spark.home.dir=$(prop 'spark.home.dir')" >> $config
            echo "spark.kryoserializer.buffer.max=2047m" >> $config
            echo "dist.input.path=$(prop 'hdfs.root.path')/$(prop 'hdfs.dist.dir')/" >> $config
            chmod -f g=u ${config}

            cd ${SCRIPT_PATH}
            # Combine end
        elif [[ "${system}" == "dbtoaster_cpp" ]]; then
            # TBD: to much script
            bash ${SCRIPT_PATH}/${system}/prepare-data.sh ${experiment} ${data_path}

            # Combine bash ${SCRIPT_PATH}/${system}/prepare-query.sh ${experiment}
            CONFIG_FILES=("${SCRIPT_PATH}/dbtoaster_cpp/${experiment}/common.cfg" "${SCRIPT_PATH}/dbtoaster_cpp/experiment.cfg")
            log_file_temp="${SCRIPT_PATH}/dbtoaster_cpp/log/prepare-query-${experiment}.log"
            mkdir -p "${SCRIPT_PATH}/dbtoaster_cpp/log"
            chmod -f g=u "${SCRIPT_PATH}/dbtoaster_cpp/log"
            rm -f ${log_file_temp}
            touch ${log_file_temp}
            chmod -f g=u ${log_file_temp}
            dbtoaster_home=$(prop 'dbtoaster.backend.home')
            cd ${dbtoaster_home}
            # TBD: query.sql
            query_file="${SCRIPT_PATH}/dbtoaster_cpp/${experiment}/query.sql"
            output_path="${SCRIPT_PATH}/dbtoaster_cpp/${experiment}"
            mkdir -p ${output_path}
            output_file="${output_path}/query.hpp"
            # substitute filter condition in sql template
            # TBD: filter
            filter_value=$(prop 'filter.condition.value' '-1')
            sed -i "s/\${filter\.condition\.value}/${filter_value}/g" "${query_file}"
            sbt "toast -l cpp -O3 --del -o ${output_file} ${query_file}" >> ${log_file_temp} 2>&1
            assert "dbtoaster compile query failed."
            exe_file="${output_path}/query.exe"
            g++-11 -O3 -std=c++14 -I "${dbtoaster_home}/ddbtoaster/release/lib/dbt_c++/lib/" -I "${dbtoaster_home}/ddbtoaster/release/lib/dbt_c++/driver/" "${dbtoaster_home}/ddbtoaster/release/lib/dbt_c++/driver/main.cpp" -include ${output_file} -o ${exe_file} >> ${log_file_temp} 2>&1
            chmod -Rf g=u "${SCRIPT_PATH}/dbtoaster_cpp/${experiment}"
            cd ${SCRIPT_PATH}
            # Combine end
        elif [[ "${system}" == "flink" ]]; then
            # Combine bash ${SCRIPT_PATH}/${system}/prepare-data.sh ${experiment} ${data_path}
            CONFIG_FILES=("${SCRIPT_PATH}/flink/${experiment}/common.cfg" "${SCRIPT_PATH}/flink/experiment.cfg" "${SCRIPT_PATH}/experiment.cfg")
            # TBD: TwoComb
            if [[ ${experiment} = "TwoComb" ]]; then
                exit 0
            fi
            target_path="${SCRIPT_PATH}/flink/src/main/resources/${experiment}"
            mkdir -p "${target_path}"
            chmod -f g=rwx "${SCRIPT_PATH}/flink/src/main/resources/${experiment}"
            rm -f "${target_path}/perf.cfg"
            touch "${target_path}/perf.cfg"
            chmod -f g=rw "${target_path}/perf.cfg"
            parallelism=$(prop 'flink.perf.parallelism')
            echo "flink.job.parallelism=${parallelism}" >> "${target_path}/perf.cfg"
            
            if [[ ${experiment} = snb* ]]; then
                # snb experiment, just set the flink.xxx.xxx.csv config to the path of csv file
                files=$(find ${data_path} -maxdepth 1 -type f -name 'flink.*.csv')
                for file in ${files[@]}; do
                    name=$(basename "${file}")
                    echo "path.to.${name}=${file}" >> "${target_path}/perf.cfg"
                done
            else
                # non snb experiment, construct flink readable data.raw and calculate the window size and step
                total_lines=$(find ${data_path} -maxdepth 1 -type f -name "*.raw" | xargs wc -l | tail -n1 | awk '{print $1}')
                window_factor=$(prop 'experiment.window.factor')
                # calculate the half_window_size first, so that window_size is always double of half_window_size
                # if we do the opposite way, window_size may be a odd number and flink won't compile(size must be n times step).
                half_window_size=$(bc <<< "${total_lines}*${window_factor}/2")
                window_size=$(bc <<< "${half_window_size}*2")

                files=$(find ${data_path} -maxdepth 1 -type f -name '*.raw')
                for file in ${files[@]}; do
                    name=$(basename "${file}")
                    # TBD: convertdata
                    bash "${SCRIPT_PATH}/data/convert-data.sh" "flink" "${data_path}/${name}" "${SCRIPT_PATH}/flink/${experiment}/${name}"
                    echo "path.to.${name}=${SCRIPT_PATH}/flink/${experiment}/${name}" >> "${target_path}/perf.cfg"
                    echo "hop.window.step=${half_window_size}" >> "${target_path}/perf.cfg"
                    # convert ${hop.window.step} seconds to xx day xx hour xx minute xx second
                    step_day=$(bc <<< "${half_window_size} / 86400")
                    step_hour=$(bc <<< "(${half_window_size} - ${step_day} * 86400) / 3600")
                    step_minute=$(bc <<< "(${half_window_size} - ${step_day} * 86400 - ${step_hour} * 3600) / 60")
                    step_second=$(bc <<< "(${half_window_size} - ${step_day} * 86400 - ${step_hour} * 3600 - ${step_minute} * 60)")
                    echo "hop.window.step.day=${step_day}" >> "${target_path}/perf.cfg"
                    echo "hop.window.step.hour=${step_hour}" >> "${target_path}/perf.cfg"
                    echo "hop.window.step.minute=${step_minute}" >> "${target_path}/perf.cfg"
                    echo "hop.window.step.second=${step_second}" >> "${target_path}/perf.cfg"

                    echo "hop.window.size=${window_size}" >> "${target_path}/perf.cfg"
                    size_day=$(bc <<< "${window_size} / 86400")
                    size_hour=$(bc <<< "(${window_size} - ${size_day} * 86400) / 3600")
                    size_minute=$(bc <<< "(${window_size} - ${size_day} * 86400 - ${size_hour} * 3600) / 60")
                    size_second=$(bc <<< "(${window_size} - ${size_day} * 86400 - ${size_hour} * 3600 - ${size_minute} * 60)")
                    echo "hop.window.size.day=${size_day}" >> "${target_path}/perf.cfg"
                    echo "hop.window.size.hour=${size_hour}" >> "${target_path}/perf.cfg"
                    echo "hop.window.size.minute=${size_minute}" >> "${target_path}/perf.cfg"
                    echo "hop.window.size.second=${size_second}" >> "${target_path}/perf.cfg"
                done
            fi
            # TBD: filter
            filter_value=$(prop 'filter.condition.value' '-1')
            echo "filter.condition.value=${filter_value}" >> "${target_path}/perf.cfg"
            # Combine end

            # Combine bash ${SCRIPT_PATH}/${system}/prepare-query.sh ${experiment}
            mkdir -p ${SCRIPT_PATH}/flink/src/main/resources/${experiment}
            chmod -f g=rwx ${SCRIPT_PATH}/flink/src/main/resources/${experiment}
            cp -f ${SCRIPT_PATH}/flink/${experiment}/*.sql ${SCRIPT_PATH}/src/main/resources/${experiment}/
            chmod -f g=rw ${SCRIPT_PATH}/flink/src/main/resources/${experiment}/*.sql
            # Combine end
        elif [[ "${system}" == "trill" ]]; then
            # Combine bash ${SCRIPT_PATH}/${system}/prepare-data.sh ${experiment} ${data_path}
            key="${experiment}.perf.path"
            pattern="^\\s*<add\\s\\s*key\\s*=\\s*\"${key}\"\\s\\s*value\\s*=\\s*\".*\"\\s*\/>\\s*$"
            app_config="${SCRIPT_PATH}/trill/app.config"
            if [[ ! -f ${app_config} ]]; then
                touch ${app_config}
                chmod -f g=rw ${app_config}
                echo "<configuration>" >> ${app_config}
                echo "<appSettings>" >> ${app_config}
                echo "</appSettings>" >> ${app_config}
                echo "</configuration>" >> ${app_config}
            fi

            if [[ -f "${SCRIPT_PATH}/trill/${experiment}/prepare-data.sh" ]]; then
                # TBD: Combine
                bash "${SCRIPT_PATH}/trill/${experiment}/prepare-data.sh" "${data_path}"
            else
                if [[ ${experiment} = snb* ]]; then
                    # snb experiments use pre-constructed input file directly
                    value="${data_path}"
                else
                    value="${SCRIPT_PATH}/trill/${experiment}"
                    files=$(find ${data_path} -maxdepth 1 -type f -name '*.csv')
                    for file in ${files[@]}; do
                        name=$(basename "${file}")
                        # TBD: convertdata
                        bash "${SCRIPT_PATH}/data/convert-data.sh" "trill" "${data_path}/${name}" "${SCRIPT_PATH}/trill/${experiment}/${name}"
                    done
                fi

                grep -q ${pattern} ${app_config} \
                && sed -i "s#${pattern}#<add key=\"${key}\" value=\"${value}\"/>#g" ${app_config} \
                || sed -i "/<appSettings>/a<add key=\"${key}\" value=\"${value}\"\/>" ${app_config}
            fi
            # Combine end
        elif [[ "${system}" == "crown" ]]; then
            # Combine bash ${SCRIPT_PATH}/${system}/prepare-data.sh ${experiment} ${data_path}
            CONFIG_FILES=("${SCRIPT_PATH}/crown/experiment.cfg")

            if [[ -f "${SCRIPT_PATH}/crown/${experiment}/prepare-data.sh" ]]; then
                # TBD: Combine
                bash "${SCRIPT_PATH}/crown/${experiment}/prepare-data.sh" ${data_path}
            else
                log_file_temp="${SCRIPT_PATH}/crown/log/prepare-data-${experiment}.log"
                mkdir -p "${SCRIPT_PATH}/crown/log"
                chmod -f g=rwx "${SCRIPT_PATH}/crown/log"
                rm -f ${log_file_temp}
                touch ${log_file_temp}
                chmod -f g=rw ${log_file_temp}
                target_path="${SCRIPT_PATH}/crown/${experiment}/perf.cfg"
                rm -f ${target_path}
                touch ${target_path}
                chmod -f g=rw ${target_path}
                files=$(find "${data_path}" -maxdepth 1 -type f -name '*.csv')
                for file in ${files[@]}
                do
                    filename=$(basename ${file})
                    echo "path.to.${filename}=${data_path}/${filename}" >> "${target_path}"
                done
            fi
            # Combine end
        else
            echo "Not support for system ${system}" >> ${log_file}
        fi
        assert "prepare data/query for system ${system} in experiment ${experiment} on mode ${experiment_mode} failed."
    done
done

for system in ${opt_system_names[@]}
do
    echo "begin to build executable for system ${system}" >> ${log_file}

    # Combine bash ${SCRIPT_PATH}/${system}/build.sh "${opt_no_func}"
    if [[ "${system}" == "dbtoaster" ]]; then
        log_file_temp="${SCRIPT_PATH}/dbtoaster/log/build.log"
        mkdir -p "${SCRIPT_PATH}/dbtoaster/log"
        chmod -f g=u "${SCRIPT_PATH}/dbtoaster/log"
        rm -f ${log_file_temp}
        touch ${log_file_temp}
        chmod -f g=u ${log_file_temp}
        cd ${SCRIPT_PATH}/dbtoaster
        rm -rf "${SCRIPT_PATH}/dbtoaster/target"
        rm -rf "${SCRIPT_PATH}/dbtoaster/project/target"
        rm -rf "${SCRIPT_PATH}/dbtoaster/project/project"
        sbt clean >> ${log_file_temp} 2>&1
        sbt compile >> ${log_file_temp} 2>&1
        assert "dbtoaster executable compile failed."
        sbt assembly >> ${log_file_temp} 2>&1
        assert "dbtoaster executable assembly failed."
        chmod -Rf g=u "${SCRIPT_PATH}/dbtoaster/target"
        chmod -Rf g=u "${SCRIPT_PATH}/dbtoaster/project"
        cd ${SCRIPT_PATH}
    elif [[ "${system}" == "dbtoaster_cpp" ]]; then
        mkdir -p "${SCRIPT_PATH}/dbtoaster_cpp/log"
        chmod -f g=u "${SCRIPT_PATH}/dbtoaster_cpp/log"
    elif [[ "${system}" == "flink" ]]; then
        log_file_temp="${SCRIPT_PATH}/flink/log/build.log"
        mkdir -p "${SCRIPT_PATH}/flink/log"
        chmod -f g=rwx "${SCRIPT_PATH}/flink/log"
        rm -f ${log_file_temp}
        touch ${log_file_temp}
        chmod -f g=rw ${log_file_temp}
        cd ${SCRIPT_PATH}/flink
        rm -rf "${SCRIPT_PATH}/flink/target/"
        mvn "clean" >> ${log_file_temp} 2>&1
        mvn "compile" "-DskipTests" >> ${log_file_temp} 2>&1
        assert "flink executable compile failed."
        mvn "package" "-DskipTests" >> ${log_file_temp} 2>&1
        assert "flink executable package failed."
        chmod -Rf g=u "${SCRIPT_PATH}/flink/target/"
        cd ${SCRIPT_PATH}
    elif [[ "${system}" == "trill" ]]; then
        log_file_temp="${SCRIPT_PATH}/trill/log/build.log"
        mkdir -p "${SCRIPT_PATH}/trill/log"
        chmod -f g=rwx "${SCRIPT_PATH}/trill/log"
        rm -f ${log_file_temp}
        touch ${log_file_temp}
        chmod -f g=rw ${log_file_temp}
        cd ${SCRIPT_PATH}/trill
        rm -rf "${SCRIPT_PATH}/trill/bin"
        rm -rf "${SCRIPT_PATH}/trill/obj"
        dotnet build "${SCRIPT_PATH}/trill/experiments-trill.csproj" "/property:GenerateFullPaths=true" "/consoleloggerparameters:NoSummary" >> ${log_file_temp} 2>&1
        assert "trill executable build failed."
        chmod -Rf g=u "${SCRIPT_PATH}/trill/bin"
        chmod -Rf g=u "${SCRIPT_PATH}/trill/obj"
        chmod -Rf g=u "${SCRIPT_PATH}/trill/bin"
        chmod -Rf g=u "${SCRIPT_PATH}/trill/obj"
        cd ${SCRIPT_PATH}
    elif [[ "${system}" == "crown" ]]; then
        CONFIG_FILES=("${SCRIPT_PATH}/crown/experiment.cfg")
        log_file_temp="${SCRIPT_PATH}/crown/log/build.log"
        mkdir -p "${SCRIPT_PATH}/crown/log"
        chmod -f g=rwx "${SCRIPT_PATH}/crown/log"
        rm -f ${log_file_temp}
        touch ${log_file_temp}
        chmod -f g=rw ${log_file_temp}
        crown_home=$(prop 'crown.code.home')
        cd ${crown_home}
        rm -rf "${crown_home}/target/"
        mvn "clean" >> ${log_file_temp} 2>&1
        mvn "compile" "-DskipTests=true" >> ${log_file_temp} 2>&1
        assert "crown compile failed."
        mvn "package" "-DskipTests=true" >> ${log_file_temp} 2>&1
        assert "crown package failed."
        chmod -Rf g=u "${crown_home}/target/"
        cd ${SCRIPT_PATH}
    else
        echo "error for system ${system}" >> ${log_file}
    fi
    # Combine end

    assert "build executable for system ${system} failed."
    echo "finish building executable for system ${system}" >> ${log_file}
done

